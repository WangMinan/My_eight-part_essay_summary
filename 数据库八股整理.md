<div align="center">
    <h1>
        数据库八股整理
    </h1>
</div>

## 一些锁

数据库里面的锁是**基于索引实现**的，在Innodb中我们的锁都是作用在索引上面的，当我们的SQL**命中索引**时，那么锁住的就是命中条件内的索引节点(行锁) ，如果**没有命中索引**的话，那我们锁的就是整个索引树（表锁 ），如下图一下锁住的是整棵树还是某几个节点，完全取决于你的条件是否有命中到对应的索引节点。

### 共享锁与排它锁，乐观锁与悲观锁

+ 共享锁【S锁】

  CountDownLatch

  又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

+ 排他锁【X锁】

  ReentrantLock

  又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

+ 乐观锁

  乐观锁是对于数据冲突保持一种乐观态度，操作数据时**不会对操作的数据进行加锁**（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来**验证**数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);

  特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。

+ 悲观锁

  顾名思义，悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是**以一种预防的姿态在修改数据之前把数据锁住**，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;

  特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;

  手动加悲观锁：读锁`LOCK tables test_db read`释放锁`UNLOCK TABLES`;

  写锁：`LOCK tables test_db WRITE`释放锁`UNLOCK TABLES`;



### 表锁、行锁、记录锁、间隙锁、临键锁。

+ 表锁

  表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；

  特点： 粒度大，加锁简单，容易冲突；

+ 行锁

  更新、删除命中索引的情况下都是行锁

  行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问；

  特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高；

+ 记录锁

  记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。

  

  ![img](https://pic1.zhimg.com/80/v2-0425f07faa3df3727d4f5769df2ff830_720w.webp)

  

  触发条件：精准条件命中，并且命中的条件字段是唯一索引；

  例如：update user_info set name=’张三’ where id=1 ,这里的id是唯一索引。

  记录锁的作用：加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。

+ 间隙锁

  间隙锁属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。

  比如下面的表里面的数据ID 为 1,4,5,7,10 ,那么会形成以下几个间隙区间，-n-1区间，1-4区间，7-10区间，10-n区间 （-n代表负无穷大，n代表正无穷大）

  

  ![img](https://pic4.zhimg.com/80/v2-691b5b3936ddd2bae289cac6356b4d97_720w.webp)

  

  **触发条件：**范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读)的事务级别中。

  **例如**：对应上图的表执行`select * from user_info where id>1 and id<4 for update`(这里的id是唯一索引) ，这个SQL查询不到对应的记录，那么此时会使用间隙锁。

  **间隙锁作用**：防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务里，A事务的两次查询出的结果会不一样。

  

  ![img](https://pic1.zhimg.com/80/v2-c02d6502983df69147e5f3d4c039cda0_720w.webp)

+ 临键锁(Next-Key Lock)

  临键锁也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是**记录锁和间隙锁的组合**，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。

  **例如：**下面表的数据执行 select * from user_info where id>1 and id<=13 for update ;

  会锁住ID为 1,5,10的记录；同时会锁住，1至5,5至10,10至15的区间。

  

  ![img](https://pic1.zhimg.com/80/v2-8c9555f753fbab98c71760ddba9e5068_720w.webp)

  

  **触发条件：**范围查询并命中，查询命中了索引。

  **临键锁的作用：**结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入。



## 索引

### B树与B+树

[平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/27700617)

### 主键索引、唯一索引、普通索引、全文索引

MySQL索引的四种类型：主键索引、唯一索引、普通索引和全文索引。

+ **主键索引:**
  主键是一种唯一性索引，但它必须指定为`PRIMARY KEY`，每个表只能有一个主键。

  ```sql
  alter table table_name add primary key (`字段名`);
  ```

+ **唯一索引:**
  索引列的所有值都只能出现一次，即必须唯一，值可以为空。

  ```sql
  alter table table_name add unique key (`字段名`);
  ```

+  **普通索引 :**
   基本的索引类型，值可以为空，没有唯一性的限制。

  ```sql
  alter table table_name add index (`字段名`);
  ```

+  **全文索引:**
  全文索引的索引类型为`FULLTEXT`。全文索引可以在`varchar、char、text`类型的列上创建。可以通过`ALTER TABLE`或CREATE INDEX命令创建。对于大规模的数据集，通过ALTER TABLE（或者CREATE INDEX）命令创建全文索引要比把记录插入带有全文索引的空表更快。`MyISAM`支持全文索引，`InnoDB`在mysql5.6之后支持了`全文索引`。    全文索引`不支持中文`需要借`sphinx(coreseek)`或`迅搜<\code>技术处理中文。`

  ```sql
  alter table table_name add fulltext key (`字段名`);
  ```

+ 对索引的一些总结

1. 为什么我们添加完索引后查询速度为变快？
   传统的查询方法，是按照表的顺序遍历的，不论查询几条数据，MySQL需要将表的数据从头到尾遍历一遍
   在我们添加完索引之后，MySQL一般通过**BTREE**算法生成一个索引文件，在查询数据库时，找到索引文件进行遍历(折半查找大幅查询效率)，找到相应的键从而获取数据

2. 索引的代价
     2.1创建索引是为产生索引文件的，占用磁盘空间`
     2.2索引文件是一个二叉树类型的文件，可想而知我们的DML操作同样也会对索引文件进行修改，所以性能会下降

3. 在哪些column上使用索引？
     3.1较频繁的作为查询条件字段应该创建索引
     3.2唯一性太差的字段不适合创建索引，尽管频繁作为查询条件，例如gender性别字段
     3.3更新非常频繁的字段不适合作为索引
     3.4不会出现在where子句中的字段不该创建索引

总结: 满足以下条件的字段，才应该创建索引.
	a: 肯定在where条`经常使用` 

​	b: 该字段的内容`不是唯一的几个值` 

​	c: 字段内容`不是频繁变化`。

### MySQL索引失效

+ **LIKE 以%或者\_开头**

  %和\_这两个是模糊匹配，如果放在开头则不走索引。

+ **OR 语句前后没有同时使用索引**

  当OR 左右查询字段**只有一个是索引，该索引失效**，只有当OR 左右查询字段均为索引时，才会生效。

+ **联合索引没遵循最左前缀原则**

  联合索引是对多个列进行索引。

  + 联合索引也是一棵B+树。
    + 联合索引的键值数量不是1，而是大于等于2。
    + B+树在对第一个索引排序的基础上，对第二个索引排序
  + 联合索引遵循最左前缀（最左匹配）原则。

  ![img](https://cdn.jsdelivr.net/gh/WangMinan/Pics/20180807153551287)

  假定上图联合索引的为（a,b），B+树在对索引a排序的基础上，对索引b排序。所以数据按照（1,1), (1,2), (2,1), (2,4), (2,4), (3,1), (3,2)顺序排放。

+ **索引列数据类型出现隐式转化**

  varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。

  例如：tb1表中name字段是字符串类型

  索引失效：`SELECT * FROM tb1 WHERE name = 123`

  索引有效：`SELECT * FROM tb1 WHERE name = '123'`

+ **对索引列进行计算或使用函数**

  原因：索引是针对**原值**建的二叉树，将列值计算后，原来的二叉树就用不上了。

  示例：

  `SELECT * FROM t WHERE id*3=3000`

  `SELECT * FROM t WHERE ABS(id)=3000`

+ **ORDER BY使用错误**

+ **全表扫描速度比索引速度快**

  此时MySQL会使用全表扫描，索引失效。

  例如：

  数据量极少的表

  表中索引字段数据重复率太高

+ **WHERE 子句中使用参数（可能失效）**

  可能会导致索引失效，与版本有关。

  原因：SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。此语句将进行全表扫描（可能）：SELECT id FROM t WHERE num = @num

  解决方案：强制查询使用索引：`SELECT id FROM t WITH(INDEX(索引名)) WHERE num = @num`

### 聚簇索引与非聚簇索引

**通俗点讲**

- 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据.一个表仅有一个聚簇索引
- 非聚簇索引：将数据存储与索引**分开存储**的结构，索引结构的**叶子节点指向了数据的对应行**，MyISAM通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key_buffer命中时，速度慢的原因

**澄清一个概念**：InnoDB中，在**聚簇索引**之上创建的索引称之为**辅助索引**，辅助索引访问数据**总是需要二次查找**，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的**不再是行的物理位置，而是主键值**。

![img](https://cdn.jsdelivr.net/gh/WangMinan/Pics/rcil81aoyd.jpeg)

**一个误区：把主键自动设为聚簇索引**

**聚簇索引默认是主键**，如果表中没有定义主键，InnoDB会选择一个**唯一的非空索引**代替。如果没有这样的索引，InnoDB会**隐式定义一个主键**来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能相距甚远。**如果你已经设置了主键为聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可**。

此时其他索引只能被定义为非聚簇索引。这个是最大的误区。有的主键还是无意义的自动增量字段，那样的话Clustered index对效率的帮助，完全被浪费了。

刚才说到了，聚簇索引性能最好而且具有唯一性，所以非常珍贵，必须慎重设置。**一般要根据这个表最常用的SQL查询方式来进行选择，某个字段作为聚簇索引，或组合聚簇索引**，这个要看实际情况。

记住我们的**最终目的**就是**在相同结果集情况下，尽可能减少逻辑I/O**。

**搜索案例**

![img](https://cdn.jsdelivr.net/gh/WangMinan/Pics/2w157wzq2u.jpeg)

![img](https://cdn.jsdelivr.net/gh/WangMinan/Pics/2q05hsflfa.jpeg)

#### **聚簇索引的优势**

看上去聚簇索引的效率明显要低于非聚簇索引，因为**每次使用辅助索引检索都要经过两次B+树查找**，这不是多此一举吗？聚簇索引的优势在哪？

1. 由于**行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问**，不必访问磁盘。这样**主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回**了，**如果按照主键Id来组织数据，获得数据更快**。
2. **辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处**是，**减少了当出现行移动或者数据页分裂时辅助索引的维护工作**，**使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"**。**也就是说行的位置（实现中通过16K的Page来定位）会随着**[**数据库**](https://cloud.tencent.com/solution/database?from=10680)**里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响**。
3. 聚簇索引适合用在排序的场合，非聚簇索引不适合
4. 取出一定范围数据的时候，使用用聚簇索引
5. 二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据
6. 可以把**相关数据保存在一起**。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。

#### **聚簇索引的劣势**

1. **维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候**。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片
2. 表因为使用UUID作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，

![img](https://cdn.jsdelivr.net/gh/WangMinan/Pics/iywj5q0imm.jpeg)

所以**建议使用int的auto_increment作为主键**

![img](https://cdn.jsdelivr.net/gh/WangMinan/Pics/td2fso5cth.jpeg)

主键的值是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB 默认的最大填充因子是页大小的 15/16，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满（二级索引页可能是不一样的）