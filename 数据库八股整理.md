<div align="center">
    <h1>
        数据库八股整理
    </h1>
</div>

### 一些锁

数据库里面的锁是**基于索引实现**的，在Innodb中我们的锁都是作用在索引上面的，当我们的SQL**命中索引**时，那么锁住的就是命中条件内的索引节点**(行锁)**，如果**没有命中索引**的话，那我们锁的就是整个索引树**（表锁）**，如下图一下锁住的是整棵树还是某几个节点，完全取决于你的条件是否有命中到对应的索引节点。

##### 共享锁与排它锁，乐观锁与悲观锁

+ 共享锁【S锁】

  CountDownLatch

  又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

+ 排他锁【X锁】

  ReentrantLock

  又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

+ 乐观锁

  乐观锁是对于数据冲突保持一种乐观态度，操作数据时**不会对操作的数据进行加锁**（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来**验证**数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);

  特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。

+ 悲观锁

  顾名思义，悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是**以一种预防的姿态在修改数据之前把数据锁住**，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;

  特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;

  手动加悲观锁：读锁`LOCK tables test_db read`释放锁`UNLOCK TABLES`;

  写锁：`LOCK tables test_db WRITE`释放锁`UNLOCK TABLES`;



##### 表锁、行锁、记录锁、间隙锁、临键锁。

+ 表锁

  表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；

  特点： 粒度大，加锁简单，容易冲突；

+ 行锁

  更新、删除命中索引的情况下都是行锁

  行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问；

  特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高；

+ 记录锁

  记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。

  

  ![img](https://pic1.zhimg.com/80/v2-0425f07faa3df3727d4f5769df2ff830_720w.webp)

  

  触发条件：精准条件命中，并且命中的条件字段是唯一索引；

  例如：update user_info set name=’张三’ where id=1 ,这里的id是唯一索引。

  记录锁的作用：加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。

+ 间隙锁

  间隙锁属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。

  比如下面的表里面的数据ID 为 1,4,5,7,10 ,那么会形成以下几个间隙区间，-n-1区间，1-4区间，7-10区间，10-n区间 （-n代表负无穷大，n代表正无穷大）

  

  ![img](https://pic4.zhimg.com/80/v2-691b5b3936ddd2bae289cac6356b4d97_720w.webp)

  

  **触发条件：**范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读)的事务级别中。

  **例如**：对应上图的表执行select * from user_info where id>1 and id<4 for update(这里的id是唯一索引) ，这个SQL查询不到对应的记录，那么此时会使用间隙锁。

  **间隙锁作用**：防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务里，A事务的两次查询出的结果会不一样。

  

  ![img](https://pic1.zhimg.com/80/v2-c02d6502983df69147e5f3d4c039cda0_720w.webp)

+ 临键锁(Next-Key Lock)

  临键锁也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是**记录锁和间隙锁的组合**，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。

  **例如：**下面表的数据执行 select * from user_info where id>1 and id<=13 for update ;

  会锁住ID为 1,5,10的记录；同时会锁住，1至5,5至10,10至15的区间。

  

  ![img](https://pic1.zhimg.com/80/v2-8c9555f753fbab98c71760ddba9e5068_720w.webp)

  

  **触发条件：**范围查询并命中，查询命中了索引。

  **临键锁的作用：**结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入。



### 索引

##### B树与B+树

[平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/27700617)